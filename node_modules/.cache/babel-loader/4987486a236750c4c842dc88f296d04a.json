{"ast":null,"code":"\"use strict\";\n/* eslint-disable no-invalid-this */\n\nvar checkError = require(\"check-error\");\n\nmodule.exports = function (chai, utils) {\n  var Assertion = chai.Assertion;\n  var assert = chai.assert;\n  var proxify = utils.proxify; // If we are using a version of Chai that has checkError on it,\n  // we want to use that version to be consistent. Otherwise, we use\n  // what was passed to the factory.\n\n  if (utils.checkError) {\n    checkError = utils.checkError;\n  }\n\n  function isLegacyJQueryPromise(thenable) {\n    // jQuery promises are Promises/A+-compatible since 3.0.0. jQuery 3.0.0 is also the first version\n    // to define the catch method.\n    return typeof thenable.catch !== \"function\" && typeof thenable.always === \"function\" && typeof thenable.done === \"function\" && typeof thenable.fail === \"function\" && typeof thenable.pipe === \"function\" && typeof thenable.progress === \"function\" && typeof thenable.state === \"function\";\n  }\n\n  function assertIsAboutPromise(assertion) {\n    if (typeof assertion._obj.then !== \"function\") {\n      throw new TypeError(utils.inspect(assertion._obj) + \" is not a thenable.\");\n    }\n\n    if (isLegacyJQueryPromise(assertion._obj)) {\n      throw new TypeError(\"Chai as Promised is incompatible with thenables of jQuery<3.0.0, sorry! Please \" + \"upgrade jQuery or use another Promises/A+ compatible library (see \" + \"http://promisesaplus.com/).\");\n    }\n  }\n\n  function proxifyIfSupported(assertion) {\n    return proxify === undefined ? assertion : proxify(assertion);\n  }\n\n  function method(name, asserter) {\n    utils.addMethod(Assertion.prototype, name, function () {\n      assertIsAboutPromise(this);\n      return asserter.apply(this, arguments);\n    });\n  }\n\n  function property(name, asserter) {\n    utils.addProperty(Assertion.prototype, name, function () {\n      assertIsAboutPromise(this);\n      return proxifyIfSupported(asserter.apply(this, arguments));\n    });\n  }\n\n  function doNotify(promise, done) {\n    promise.then(function () {\n      return done();\n    }, done);\n  } // These are for clarity and to bypass Chai refusing to allow `undefined` as actual when used with `assert`.\n\n\n  function assertIfNegated(assertion, message, extra) {\n    assertion.assert(true, null, message, extra.expected, extra.actual);\n  }\n\n  function assertIfNotNegated(assertion, message, extra) {\n    assertion.assert(false, message, null, extra.expected, extra.actual);\n  }\n\n  function getBasePromise(assertion) {\n    // We need to chain subsequent asserters on top of ones in the chain already (consider\n    // `eventually.have.property(\"foo\").that.equals(\"bar\")`), only running them after the existing ones pass.\n    // So the first base-promise is `assertion._obj`, but after that we use the assertions themselves, i.e.\n    // previously derived promises, to chain off of.\n    return typeof assertion.then === \"function\" ? assertion : assertion._obj;\n  }\n\n  function getReasonName(reason) {\n    return reason instanceof Error ? reason.toString() : checkError.getConstructorName(reason);\n  } // Grab these first, before we modify `Assertion.prototype`.\n\n\n  var propertyNames = Object.getOwnPropertyNames(Assertion.prototype);\n  var propertyDescs = {};\n  var _iteratorNormalCompletion = true;\n  var _didIteratorError = false;\n  var _iteratorError = undefined;\n\n  try {\n    for (var _iterator = propertyNames[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n      var name = _step.value;\n      propertyDescs[name] = Object.getOwnPropertyDescriptor(Assertion.prototype, name);\n    }\n  } catch (err) {\n    _didIteratorError = true;\n    _iteratorError = err;\n  } finally {\n    try {\n      if (!_iteratorNormalCompletion && _iterator.return != null) {\n        _iterator.return();\n      }\n    } finally {\n      if (_didIteratorError) {\n        throw _iteratorError;\n      }\n    }\n  }\n\n  property(\"fulfilled\", function () {\n    var _this = this;\n\n    var derivedPromise = getBasePromise(this).then(function (value) {\n      assertIfNegated(_this, \"expected promise not to be fulfilled but it was fulfilled with #{act}\", {\n        actual: value\n      });\n      return value;\n    }, function (reason) {\n      assertIfNotNegated(_this, \"expected promise to be fulfilled but it was rejected with #{act}\", {\n        actual: getReasonName(reason)\n      });\n      return reason;\n    });\n    module.exports.transferPromiseness(this, derivedPromise);\n    return this;\n  });\n  property(\"rejected\", function () {\n    var _this2 = this;\n\n    var derivedPromise = getBasePromise(this).then(function (value) {\n      assertIfNotNegated(_this2, \"expected promise to be rejected but it was fulfilled with #{act}\", {\n        actual: value\n      });\n      return value;\n    }, function (reason) {\n      assertIfNegated(_this2, \"expected promise not to be rejected but it was rejected with #{act}\", {\n        actual: getReasonName(reason)\n      }); // Return the reason, transforming this into a fulfillment, to allow further assertions, e.g.\n      // `promise.should.be.rejected.and.eventually.equal(\"reason\")`.\n\n      return reason;\n    });\n    module.exports.transferPromiseness(this, derivedPromise);\n    return this;\n  });\n  method(\"rejectedWith\", function (errorLike, errMsgMatcher, message) {\n    var _this3 = this;\n\n    var errorLikeName = null;\n    var negate = utils.flag(this, \"negate\") || false; // rejectedWith with that is called without arguments is\n    // the same as a plain \".rejected\" use.\n\n    if (errorLike === undefined && errMsgMatcher === undefined && message === undefined) {\n      /* eslint-disable no-unused-expressions */\n      return this.rejected;\n      /* eslint-enable no-unused-expressions */\n    }\n\n    if (message !== undefined) {\n      utils.flag(this, \"message\", message);\n    }\n\n    if (errorLike instanceof RegExp || typeof errorLike === \"string\") {\n      errMsgMatcher = errorLike;\n      errorLike = null;\n    } else if (errorLike && errorLike instanceof Error) {\n      errorLikeName = errorLike.toString();\n    } else if (typeof errorLike === \"function\") {\n      errorLikeName = checkError.getConstructorName(errorLike);\n    } else {\n      errorLike = null;\n    }\n\n    var everyArgIsDefined = Boolean(errorLike && errMsgMatcher);\n    var matcherRelation = \"including\";\n\n    if (errMsgMatcher instanceof RegExp) {\n      matcherRelation = \"matching\";\n    }\n\n    var derivedPromise = getBasePromise(this).then(function (value) {\n      var assertionMessage = null;\n      var expected = null;\n\n      if (errorLike) {\n        assertionMessage = \"expected promise to be rejected with #{exp} but it was fulfilled with #{act}\";\n        expected = errorLikeName;\n      } else if (errMsgMatcher) {\n        assertionMessage = \"expected promise to be rejected with an error \".concat(matcherRelation, \" #{exp} but \") + \"it was fulfilled with #{act}\";\n        expected = errMsgMatcher;\n      }\n\n      assertIfNotNegated(_this3, assertionMessage, {\n        expected: expected,\n        actual: value\n      });\n      return value;\n    }, function (reason) {\n      var errorLikeCompatible = errorLike && (errorLike instanceof Error ? checkError.compatibleInstance(reason, errorLike) : checkError.compatibleConstructor(reason, errorLike));\n      var errMsgMatcherCompatible = errMsgMatcher && checkError.compatibleMessage(reason, errMsgMatcher);\n      var reasonName = getReasonName(reason);\n\n      if (negate && everyArgIsDefined) {\n        if (errorLikeCompatible && errMsgMatcherCompatible) {\n          _this3.assert(true, null, \"expected promise not to be rejected with #{exp} but it was rejected \" + \"with #{act}\", errorLikeName, reasonName);\n        }\n      } else {\n        if (errorLike) {\n          _this3.assert(errorLikeCompatible, \"expected promise to be rejected with #{exp} but it was rejected with #{act}\", \"expected promise not to be rejected with #{exp} but it was rejected \" + \"with #{act}\", errorLikeName, reasonName);\n        }\n\n        if (errMsgMatcher) {\n          _this3.assert(errMsgMatcherCompatible, \"expected promise to be rejected with an error \".concat(matcherRelation, \" #{exp} but got \") + \"#{act}\", \"expected promise not to be rejected with an error \".concat(matcherRelation, \" #{exp}\"), errMsgMatcher, checkError.getMessage(reason));\n        }\n      }\n\n      return reason;\n    });\n    module.exports.transferPromiseness(this, derivedPromise);\n    return this;\n  });\n  property(\"eventually\", function () {\n    utils.flag(this, \"eventually\", true);\n    return this;\n  });\n  method(\"notify\", function (done) {\n    doNotify(getBasePromise(this), done);\n    return this;\n  });\n  method(\"become\", function (value, message) {\n    return this.eventually.deep.equal(value, message);\n  }); // ### `eventually`\n  // We need to be careful not to trigger any getters, thus `Object.getOwnPropertyDescriptor` usage.\n\n  var methodNames = propertyNames.filter(function (name) {\n    return name !== \"assert\" && typeof propertyDescs[name].value === \"function\";\n  });\n  methodNames.forEach(function (methodName) {\n    Assertion.overwriteMethod(methodName, function (originalMethod) {\n      return function () {\n        return doAsserterAsyncAndAddThen(originalMethod, this, arguments);\n      };\n    });\n  });\n  var getterNames = propertyNames.filter(function (name) {\n    return name !== \"_obj\" && typeof propertyDescs[name].get === \"function\";\n  });\n  getterNames.forEach(function (getterName) {\n    // Chainable methods are things like `an`, which can work both for `.should.be.an.instanceOf` and as\n    // `should.be.an(\"object\")`. We need to handle those specially.\n    var isChainableMethod = Assertion.prototype.__methods.hasOwnProperty(getterName);\n\n    if (isChainableMethod) {\n      Assertion.overwriteChainableMethod(getterName, function (originalMethod) {\n        return function () {\n          return doAsserterAsyncAndAddThen(originalMethod, this, arguments);\n        };\n      }, function (originalGetter) {\n        return function () {\n          return doAsserterAsyncAndAddThen(originalGetter, this);\n        };\n      });\n    } else {\n      Assertion.overwriteProperty(getterName, function (originalGetter) {\n        return function () {\n          return proxifyIfSupported(doAsserterAsyncAndAddThen(originalGetter, this));\n        };\n      });\n    }\n  });\n\n  function doAsserterAsyncAndAddThen(asserter, assertion, args) {\n    // Since we're intercepting all methods/properties, we need to just pass through if they don't want\n    // `eventually`, or if we've already fulfilled the promise (see below).\n    if (!utils.flag(assertion, \"eventually\")) {\n      asserter.apply(assertion, args);\n      return assertion;\n    }\n\n    var derivedPromise = getBasePromise(assertion).then(function (value) {\n      // Set up the environment for the asserter to actually run: `_obj` should be the fulfillment value, and\n      // now that we have the value, we're no longer in \"eventually\" mode, so we won't run any of this code,\n      // just the base Chai code that we get to via the short-circuit above.\n      assertion._obj = value;\n      utils.flag(assertion, \"eventually\", false);\n      return args ? module.exports.transformAsserterArgs(args) : args;\n    }).then(function (newArgs) {\n      asserter.apply(assertion, newArgs); // Because asserters, for example `property`, can change the value of `_obj` (i.e. change the \"object\"\n      // flag), we need to communicate this value change to subsequent chained asserters. Since we build a\n      // promise chain paralleling the asserter chain, we can use it to communicate such changes.\n\n      return assertion._obj;\n    });\n    module.exports.transferPromiseness(assertion, derivedPromise);\n    return assertion;\n  } // ### Now use the `Assertion` framework to build an `assert` interface.\n\n\n  var originalAssertMethods = Object.getOwnPropertyNames(assert).filter(function (propName) {\n    return typeof assert[propName] === \"function\";\n  });\n\n  assert.isFulfilled = function (promise, message) {\n    return new Assertion(promise, message).to.be.fulfilled;\n  };\n\n  assert.isRejected = function (promise, errorLike, errMsgMatcher, message) {\n    var assertion = new Assertion(promise, message);\n    return assertion.to.be.rejectedWith(errorLike, errMsgMatcher, message);\n  };\n\n  assert.becomes = function (promise, value, message) {\n    return assert.eventually.deepEqual(promise, value, message);\n  };\n\n  assert.doesNotBecome = function (promise, value, message) {\n    return assert.eventually.notDeepEqual(promise, value, message);\n  };\n\n  assert.eventually = {};\n  originalAssertMethods.forEach(function (assertMethodName) {\n    assert.eventually[assertMethodName] = function (promise) {\n      var otherArgs = Array.prototype.slice.call(arguments, 1);\n      var customRejectionHandler;\n      var message = arguments[assert[assertMethodName].length - 1];\n\n      if (typeof message === \"string\") {\n        customRejectionHandler = function customRejectionHandler(reason) {\n          throw new chai.AssertionError(\"\".concat(message, \"\\n\\nOriginal reason: \").concat(utils.inspect(reason)));\n        };\n      }\n\n      var returnedPromise = promise.then(function (fulfillmentValue) {\n        return assert[assertMethodName].apply(assert, [fulfillmentValue].concat(otherArgs));\n      }, customRejectionHandler);\n\n      returnedPromise.notify = function (done) {\n        doNotify(returnedPromise, done);\n      };\n\n      return returnedPromise;\n    };\n  });\n};\n\nmodule.exports.transferPromiseness = function (assertion, promise) {\n  assertion.then = promise.then.bind(promise);\n};\n\nmodule.exports.transformAsserterArgs = function (values) {\n  return values;\n};","map":null,"metadata":{},"sourceType":"script"}